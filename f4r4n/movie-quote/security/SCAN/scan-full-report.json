{"tool": {"driver": {"name": "Secrets Audit", "rules": [{"id": "CWE-312", "help": {"text": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\nBecause the information is stored in cleartext, attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.", "markdown": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\nBecause the information is stored in cleartext, attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information."}, "name": "Env Var", "properties": {"tags": ["Scan"], "precision": "very-high"}, "defaultConfiguration": {"level": "error"}, "fullDescription": {"text": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere."}, "helpUri": "https://cwe.mitre.org/data/definitions/312.html", "shortDescription": {"text": "Cleartext Storage of Sensitive Information."}}], "version": "1.0.0-scan", "fullName": "Secrets Audit"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["--config-path=/usr/local/src/lib/../credscan-config.toml", "--path=/github/workspace", "--leaks-exit-code=0", "--no-git", "--report=/github/workspace/reports/credscan-report.json"], "executionSuccessful": true, "commandLine": "--config-path=/usr/local/src/lib/../credscan-config.toml --path=/github/workspace --leaks-exit-code=0 --no-git --report=/github/workspace/reports/credscan-report.json", "endTimeUtc": "2023-02-14T08:32:54Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-14T08:32:54Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}], "properties": {"metrics": {"total": 11, "critical": 0, "high": 11, "medium": 0, "low": 0}}, "results": [{"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine: EMAIL_HOST_PASSWORD = os.environ.get(\"EMAIL_PASSWORD\")\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "EMAIL_HOST_PASSWORD = os.environ.get(\"EMAIL_PASSWORD\")"}, "startLine": 141}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/local-settings.py"}, "contextRegion": {"snippet": {"text": "EMAIL_HOST_PASSWORD = os.environ.get(\"EMAIL_PASSWORD\")"}, "endLine": 141, "startLine": 141}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "ee072696fe90e883", "scanFileHash": "23ab1eec1492abe5"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine: EMAIL_HOST_PASSWORD = os.environ.get(\"CONFIG_EMAIL_HOST_PASSWORD\")\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "EMAIL_HOST_PASSWORD = os.environ.get(\"CONFIG_EMAIL_HOST_PASSWORD\")"}, "startLine": 12}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "EMAIL_HOST_PASSWORD = os.environ.get(\"CONFIG_EMAIL_HOST_PASSWORD\")"}, "endLine": 12, "startLine": 12}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "8dc328e9fdf7b59a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:         \"PASSWORD\": os.environ.get(\"DB_PASSWORD\"),\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "        \"PASSWORD\": os.environ.get(\"DB_PASSWORD\"),"}, "startLine": 73}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "        \"PASSWORD\": os.environ.get(\"DB_PASSWORD\"),"}, "endLine": 73, "startLine": 73}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "df7e22deb523ced7", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\","}, "startLine": 1825}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\","}, "endLine": 1825, "startLine": 1825}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "9a9382839a3e1373", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\""}, "startLine": 1826}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\""}, "endLine": 1826, "startLine": 1826}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "a541855ffb7a5ce5", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\","}, "startLine": 1852}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\","}, "endLine": 1852, "startLine": 1852}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "e77b24ab4c24cf2f", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\""}, "startLine": 1853}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\""}, "endLine": 1853, "startLine": 1853}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "8ce0e3e0f924c6a2", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\","}, "startLine": 2122}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\","}, "endLine": 2122, "startLine": 2122}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d29ab106b256255d", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\""}, "startLine": 2123}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\""}, "endLine": 2123, "startLine": 2123}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "1d1c2da8d5dd1d46", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\","}, "startLine": 2257}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\","}, "endLine": 2257, "startLine": 2257}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "ace693e453ef5296", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\""}, "startLine": 2258}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\""}, "endLine": 2258, "startLine": 2258}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "c9558570234d0134", "scanFileHash": "c5e291a2a8c8745f"}, "ruleId": "CWE-312", "ruleIndex": 0}], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "cf868ca0-aeac-40a4-9c5a-ac07a3383a31"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
{"tool": {"driver": {"name": "Shell Script Analysis", "version": "1.0.0-scan", "fullName": "Shell Script Analysis"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["-a", "--shell=bash", "-f", "json", "-S", "error", "--color=never", "/github/workspace/env.sh"], "executionSuccessful": true, "commandLine": "-a --shell=bash -f json -S error --color=never /github/workspace/env.sh", "endTimeUtc": "2023-02-14T08:32:53Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-14T08:32:53Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}], "properties": {"metrics": {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0}}, "results": [], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "4d224826-10d7-4ee6-b5c2-f973fabf3832"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
{"tool": {"driver": {"name": "Python Source Analyzer", "version": "1.0.0-scan", "fullName": "Python Source Analyzer"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["-r", "-a", "vuln", "-n", "3", "-s", "B101,B102,B105,B307,B308,B310,B322,B404,B601,B602,B603,B604,B605,B701,B702,B703", "-iii", "-ll", "-o", "/github/workspace/reports/source-python-report.json", "-f", "json", "-x", ".git,.svn,.mvn,.idea,.github,.hg,dist,obj,backup,docs,tests,test,test-packages,tmp,report,reports,node_modules,.terraform,.serverless,venv,.virtualenv,vendor,bower_components,.vscode,e2e,.pytest_cache,__pycache__,.storybook,.venv,.tox,examples,tutorials,samples,migrations,db_migrations,unittests,unittests_legacy,stubs,cypress,mock,mocks", "/github/workspace"], "executionSuccessful": true, "commandLine": "-r -a vuln -n 3 -s B101,B102,B105,B307,B308,B310,B322,B404,B601,B602,B603,B604,B605,B701,B702,B703 -iii -ll -o /github/workspace/reports/source-python-report.json -f json -x .git,.svn,.mvn,.idea,.github,.hg,dist,obj,backup,docs,tests,test,test-packages,tmp,report,reports,node_modules,.terraform,.serverless,venv,.virtualenv,vendor,bower_components,.vscode,e2e,.pytest_cache,__pycache__,.storybook,.venv,.tox,examples,tutorials,samples,migrations,db_migrations,unittests,unittests_legacy,stubs,cypress,mock,mocks /github/workspace", "endTimeUtc": "2023-02-14T08:32:53Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-14T08:32:53Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}], "properties": {"metrics": {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0}}, "results": [], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "c984c12f-26f9-4cca-aa68-d971a7039cd7"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
{"tool": {"driver": {"name": "Python Security Analysis", "rules": [{"id": "django-misconfiguration-static", "help": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.", "markdown": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data."}, "name": "Security Misconfiguration", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "note"}, "fullDescription": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors."}, "helpUri": "https://cwe.mitre.org/data/definitions/732.html", "shortDescription": {"text": "Incorrect Permission Assignment for Critical Resource."}}, {"id": "django-misconfiguration-insecure", "help": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.", "markdown": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data."}, "name": "Security Misconfiguration", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "note"}, "fullDescription": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors."}, "helpUri": "https://cwe.mitre.org/data/definitions/732.html", "shortDescription": {"text": "Incorrect Permission Assignment for Critical Resource."}}, {"id": "django-misconfiguration-recommended", "help": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.", "markdown": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data."}, "name": "Security Misconfiguration", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "warning"}, "fullDescription": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors."}, "helpUri": "https://cwe.mitre.org/data/definitions/732.html", "shortDescription": {"text": "Incorrect Permission Assignment for Critical Resource."}}, {"id": "django-sec-recommended", "help": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.", "markdown": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data."}, "name": "Security Misconfiguration", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "note"}, "fullDescription": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors."}, "helpUri": "https://cwe.mitre.org/data/definitions/732.html", "shortDescription": {"text": "Incorrect Permission Assignment for Critical Resource."}}], "version": "1.0.0-scan", "fullName": "Python Security Analysis"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["-j", "-a", "e", "-o", "/github/workspace/reports/taint-python-report.json"], "executionSuccessful": true, "commandLine": "-j -a e -o /github/workspace/reports/taint-python-report.json", "endTimeUtc": "2023-02-14T08:32:53Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-14T08:32:53Z", "workingDirectory": {"uri": "https://github.com/f4r4n/movie-quote"}}], "properties": {"metrics": {"total": 18, "critical": 0, "high": 0, "medium": 14, "low": 4}}, "results": [{"message": {"markdown": "", "text": "Security Misconfiguration with the config `EMAIL_USE_TLS` set to a static value `True`."}, "level": "note", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "EMAIL_USE_TLS = True\n"}, "startLine": 13}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "EMAIL_HOST_PASSWORD = os.environ.get(\"CONFIG_EMAIL_HOST_PASSWORD\")\nEMAIL_USE_TLS = True\nEMAIL_PORT = 587\n# django configs\n"}, "endLine": 15, "startLine": 12}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "LOW", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "89146dcfe53959a9", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-static", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SECRET_KEY` set to a static value `None`."}, "level": "note", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "SECRET_KEY = str(os.environ.get(\"CONFIG_SECRET_KEY\"))\n"}, "startLine": 16}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "# django configs\nSECRET_KEY = str(os.environ.get(\"CONFIG_SECRET_KEY\"))\nDEBUG = bool(int(os.environ.get(\"CONFIG_DEBUG\", 0)))\nALLOWED_HOSTS = os.environ.get(\"CONFIG_ALLOWED_HOSTS\", []).split(\", \")\n"}, "endLine": 18, "startLine": 15}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "LOW", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "6a35d84a98b2eaae", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-static", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `DEBUG` set to a value `None` meant for development use."}, "level": "note", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "DEBUG = bool(int(os.environ.get(\"CONFIG_DEBUG\", 0)))\n"}, "startLine": 17}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "SECRET_KEY = str(os.environ.get(\"CONFIG_SECRET_KEY\"))\nDEBUG = bool(int(os.environ.get(\"CONFIG_DEBUG\", 0)))\nALLOWED_HOSTS = os.environ.get(\"CONFIG_ALLOWED_HOSTS\", []).split(\", \")\n\n"}, "endLine": 19, "startLine": 16}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "LOW", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "71cc0ff5bd96a8ce", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-insecure", "ruleIndex": 1}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `CSRF_COOKIE_DOMAIN` not set to the recommended value `domain name` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `CSRF_USE_SESSIONS` not set to the recommended value `True` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `CSRF_COOKIE_SECURE` not set to the recommended value `True` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `CSRF_TRUSTED_ORIGINS` not set to the recommended value `domain name` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `DATA_UPLOAD_MAX_MEMORY_SIZE` not set to the recommended value `2621440` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `DATA_UPLOAD_MAX_NUMBER_FIELDS` not set to the recommended value `100` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `FILE_UPLOAD_MAX_MEMORY_SIZE` not set to the recommended value `2621440` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SECURE_BROWSER_XSS_FILTER` not set to the recommended value `True` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SECURE_CONTENT_TYPE_NOSNIFF` not set to the recommended value `True` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SECURE_HSTS_INCLUDE_SUBDOMAINS` not set to the recommended value `True` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SECURE_HSTS_PRELOAD` not set to the recommended value `True` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SECURE_REDIRECT_EXEMPT` not set to the recommended value `domain name` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `AUTHENTICATION_BACKENDS` not set to the recommended value `['django.contrib.auth.backends.ModelBackend']` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Security Misconfiguration with the config `SESSION_COOKIE_DOMAIN` not set to the recommended value `domain name` for production use."}, "locations": [{"physicalLocation": {"region": {"snippet": {"text": "from pathlib import Path\n"}, "startLine": 1}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "from pathlib import Path\nfrom datetime import timedelta\nimport os\n\n"}, "endLine": 4, "startLine": 1}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "MEDIUM", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d25afab95d81fd7a", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-misconfiguration-recommended", "ruleIndex": 2}, {"message": {"markdown": "", "text": "Consider including CSRF protection middleware for django applications."}, "level": "note", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "MIDDLEWARE = [\n"}, "startLine": 37}, "artifactLocation": {"uri": "https://github.com/f4r4n/movie-quote/config/settings.py"}, "contextRegion": {"snippet": {"text": "\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'corsheaders.middleware.CorsMiddleware',\n"}, "endLine": 39, "startLine": 36}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "LOW", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "7627f7fa13ae033c", "scanFileHash": "edcf00df05cddabe"}, "ruleId": "django-sec-recommended", "ruleIndex": 3}], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "441769df-6977-4a98-9a1f-bd0af930d6d2"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
