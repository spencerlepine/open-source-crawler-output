{"id": "CVE-2021-44906", "package": "npm:minimist", "package_type": "npm", "package_usage": "optional", "version": "<1.2.6", "fix_version": "1.2.6", "severity": "CRITICAL", "cvss_score": "9.0", "short_description": "# Prototype Pollution in minimist\nMinimist <=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69 95).\nUpgrade to version 1.2.6 or later\n            ", "related_urls": []}
{"id": "CVE-2022-24773", "package": "npm:node-forge", "package_type": "npm", "package_usage": "optional", "version": "<1.3.0", "fix_version": "1.3.0", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# Improper Verification of Cryptographic Signature in `node forge`\n### Impact\n\nRSA PKCS#1 v1.5 signature verification code is not properly checking `DigestInfo` for a proper ASN.1 structure. This can lead to successful verification with signatures that contain invalid structures but a valid digest.\n\n### Patches\n\nThe issue has been addressed in `node forge` `1.3.0`.\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n* Open an issue in [forge (https://github.com/digitalbazaar/forge)\n* Email us at [example email address (mailto:security@digitalbazaar.com)\nUpgrade to version 1.3.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-24772", "package": "npm:node-forge", "package_type": "npm", "package_usage": "optional", "version": "<1.3.0", "fix_version": "1.3.0", "severity": "HIGH", "cvss_score": "7.5", "short_description": "# Improper Verification of Cryptographic Signature in node forge\n### Impact\n\nRSA PKCS#1 v1.5 signature verification code does not check for tailing garbage bytes after decoding a `DigestInfo` ASN.1 structure. This can allow padding bytes to be removed and garbage data added to forge a signature when a low public exponent is being used.\n\n### Patches\n\nThe issue has been addressed in `node forge` `1.3.0`.\n\n### References\n\nFor more information, please see\n[\"Bleichenbacher's RSA signature forgery based on implementation error\" (https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/)\nby Hal Finney.\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n* Open an issue in [forge (https://github.com/digitalbazaar/forge)\n* Email us at [example email address (mailto:security@digitalbazaar.com)\nUpgrade to version 1.3.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-24771", "package": "npm:node-forge", "package_type": "npm", "package_usage": "optional", "version": "<1.3.0", "fix_version": "1.3.0", "severity": "HIGH", "cvss_score": "7.5", "short_description": "# Improper Verification of Cryptographic Signature in node forge\n### Impact\n\nRSA PKCS#1 v1.5 signature verification code is lenient in checking the digest algorithm structure. This can allow a crafted structure that steals padding bytes and uses unchecked portion of the PKCS#1 encoded message to forge a signature when a low public exponent is being used.\n\n### Patches\n\nThe issue has been addressed in `node forge` `1.3.0`.\n\n### References\n\nFor more information, please see\n[\"Bleichenbacher's RSA signature forgery based on implementation error\" (https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/)\nby Hal Finney.\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n* Open an issue in [forge (https://github.com/digitalbazaar/forge)\n* Email us at [example email address (mailto:security@digitalbazaar.com)\nUpgrade to version 1.3.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-24434", "package": "npm:dicer", "package_type": "npm", "package_usage": "optional", "version": "<=0.3.1", "fix_version": null, "severity": "HIGH", "cvss_score": "7.5", "short_description": "# Crash in HeaderParser in dicer\nThis affects all versions of package dicer. A malicious attacker can send a modified form to server, and crash the nodejs service. A complete denial of service can be achived by sending the malicious form in a loop.\nNone\n            ", "related_urls": []}
{"id": "CVE-2022-33987", "package": "npm:got", "package_type": "npm", "package_usage": "optional", "version": "<11.8.5", "fix_version": "11.8.5", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# Got allows a redirect to a UNIX socket\nThe got package before 11.8.5 and 12.1.0 for Node.js allows a redirect to a UNIX socket.\nUpgrade to version 11.8.5 or later\n            ", "related_urls": []}
{"id": "CVE-2022-32210", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": ">=4.8.2-<=5.5.0", "fix_version": "5.5.1", "severity": "HIGH", "cvss_score": "7.5", "short_description": "# ProxyAgent vulnerable to MITM\n### Description\n\n`Undici.ProxyAgent` never verifies the remote server's certificate, and always exposes all request & response data to the proxy. This unexpectedly means that proxies can MitM all HTTPS traffic, and if the proxy's URL is HTTP then it also means that nominally HTTPS requests are actually sent via plain text HTTP between Undici and the proxy server.\n\n### Impact\n\nThis affects all use of HTTPS via HTTP proxy using **`Undici.ProxyAgent`**  with Undici or Node's global `fetch`. In this case, it removes all HTTPS security from all requests sent using Undici's `ProxyAgent`, allowing trivial MitM attacks by anybody on the network path between the client and the target server (local network users, your ISP, the proxy, the target server's ISP, etc).\nThis less seriously affects HTTPS via HTTPS proxies. When you send HTTPS via a proxy to a remote server, the proxy can freely view or modify all HTTPS traffic unexpectedly (but only the proxy). \n\n### Patches\n\nThis issue was patched in Undici v5.5.1.\n\n### Workarounds\n\nAt the time of writing, the only workaround is to not use `ProxyAgent` as a dispatcher for TLS Connections.\nUpgrade to version 5.5.1 or later\n            ", "related_urls": []}
{"id": "CVE-2022-35949", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<=5.8.1", "fix_version": "5.8.2", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# `undici.request` vulnerable to SSRF using absolute URL on `pathname`\n### Impact\n\n`undici` is vulnerable to SSRF (Server side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`.\n\nIf a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1`\n\n```js\nconst undici = require(\"undici\")\nundici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"})\n```\n\nInstead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`.\n\nIf a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL.\n\n### Patches\n\nThis issue was fixed in `undici@5.8.1`.\n\n### Workarounds\n\nThe best workaround is to validate user input before passing it to the `undici.request` call.\n\n## For more information\nIf you have any questions or comments about this advisory:\n\n  Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n  To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\n\nUpgrade to version 5.8.2 or later\n            ", "related_urls": []}
{"id": "CVE-2022-35948", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<=5.8.1", "fix_version": "5.8.2", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# Nodejs \u2018undici\u2019 Vulnerable to CRLF Injection via Content Type\n### Impact\n\n`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content type` header.\n\nExample:\n\n```\nimport { request } from 'undici'\n\nconst unsanitizedContentTypeInput =  'application/json r n r nGET /foo2 HTTP/1.1'\n\nawait request('http://localhost:3000, {\n    method: 'GET',\n    headers: {\n      'content type': unsanitizedContentTypeInput\n    },\n})\n```\n\nThe above snippet will perform two requests in a single `request` API call:\n\n1) `http://localhost:3000/`\n2) `http://localhost:3000/foo2`\n\n### Patches\n\nThis issue was patched in Undici v5.8.1\n\n### Workarounds\n\nSanitize input when sending content type headers using user input.\n\n## For more information\nIf you have any questions or comments about this advisory:\n\n  Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n  To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\nUpgrade to version 5.8.2 or later\n            ", "related_urls": []}
{"id": "CVE-2022-31151", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<5.8.0", "fix_version": "5.8.0", "severity": "LOW", "cvss_score": "2.0", "short_description": "# undici before v5.8.0 vulnerable to uncleared cookies on cross host / cross origin redirect\n### Impact\n\nAuthorization headers are already cleared on cross origin redirect in\nhttps://github.com/nodejs/undici/blob/main/lib/handler/redirect.js#L189, based on https://github.com/nodejs/undici/issues/872.\n\nHowever, cookie headers which are sensitive headers and are official headers found in the spec, remain uncleared. There also has been active discussion of implementing a cookie store https://github.com/nodejs/undici/pull/1441, which suggests that there are active users using cookie headers in undici.\nAs such this may lead to accidental leakage of cookie to a 3rd party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the 3rd party site.\n\n### Patches\n\nThis was patched in v5.8.0.\n\n### Workarounds\n\nBy default, this vulnerability is not exploitable.\nDo not enable redirections, i.e. `maxRedirections: 0` (the default). \n\n### References\n\nhttps://hackerone.com/reports/1635514\nhttps://curl.se/docs/CVE 2018 1000007.html\nhttps://curl.se/docs/CVE 2022 27776.html\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n* To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\n\nUpgrade to version 5.8.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-31150", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<5.8.0", "fix_version": "5.8.0", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# undici before v5.8.0 vulnerable to CRLF injection in request headers\n### Impact\n\nIt is possible to inject CRLF sequences into request headers in Undici.\n\n```js\nconst undici = require('undici')\n\nconst response = undici.request(\"http://127.0.0.1:1000\", {\n  headers: {'a': \" r nb\"}\n})\n```\n\nThe same applies to `path` and `method`\n\n### Patches\n\nUpdate to v5.8.0\n\n### Workarounds\n\nSanitize all HTTP headers from untrusted sources to eliminate ` r n`.\n\n### References\n\nhttps://hackerone.com/reports/409943\nhttps://cve.mitre.org/cgi bin/cvename.cgi?name=CVE 2018 12116\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n\n* Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n* To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\n\nUpgrade to version 5.8.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-3517", "package": "npm:minimatch", "package_type": "npm", "package_usage": "optional", "version": "<3.0.5", "fix_version": "3.0.5", "severity": "HIGH", "cvss_score": "7.5", "short_description": "# minimatch ReDoS vulnerability\nA vulnerability was found in the minimatch package. This flaw allows a Regular Expression Denial of Service (ReDoS) when calling the braceExpand function with specific arguments, resulting in a Denial of Service.\nUpgrade to version 3.0.5 or later\n            ", "related_urls": []}
{"id": "CVE-2022-37601", "package": "npm:loader-utils", "package_type": "npm", "package_usage": "optional", "version": ">=2.0.0-<2.0.3", "fix_version": "2.0.3", "severity": "CRITICAL", "cvss_score": "9.0", "short_description": "# Prototype pollution in webpack loader utils\nPrototype pollution vulnerability in function parseQuery in parseQuery.js in webpack loader utils prior to version 2.0.3 via the name variable in parseQuery.js.\nUpgrade to version 2.0.3 or later\n            ", "related_urls": []}
