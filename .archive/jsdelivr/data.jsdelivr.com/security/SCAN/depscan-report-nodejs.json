{"id": "CVE-2021-33623", "package": "npm:trim-newlines", "package_type": "npm", "package_usage": "optional", "version": "<3.0.1", "fix_version": "3.0.1", "severity": "HIGH", "cvss_score": "7.5", "short_description": "# Uncontrolled Resource Consumption in trim newlines\n@rkesters/gnuplot is an easy to use node module to draw charts using gnuplot and ps2pdf. The trim newlines package before 3.0.1 and 4.x before 4.0.1 for Node.js has an issue related to regular expression denial of service (ReDoS) for the .end() method.\nUpgrade to version 3.0.1 or later\n            ", "related_urls": []}
{"id": "CVE-2022-33987", "package": "npm:got", "package_type": "npm", "package_usage": "optional", "version": "<11.8.5", "fix_version": "11.8.5", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# Got allows a redirect to a UNIX socket\nThe got package before 11.8.5 and 12.1.0 for Node.js allows a redirect to a UNIX socket.\nUpgrade to version 11.8.5 or later\n            ", "related_urls": []}
{"id": "CVE-2022-32210", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": ">=4.8.2-<=5.5.0", "fix_version": "5.5.1", "severity": "HIGH", "cvss_score": "7.5", "short_description": "# ProxyAgent vulnerable to MITM\n### Description\n\n`Undici.ProxyAgent` never verifies the remote server's certificate, and always exposes all request & response data to the proxy. This unexpectedly means that proxies can MitM all HTTPS traffic, and if the proxy's URL is HTTP then it also means that nominally HTTPS requests are actually sent via plain text HTTP between Undici and the proxy server.\n\n### Impact\n\nThis affects all use of HTTPS via HTTP proxy using **`Undici.ProxyAgent`**  with Undici or Node's global `fetch`. In this case, it removes all HTTPS security from all requests sent using Undici's `ProxyAgent`, allowing trivial MitM attacks by anybody on the network path between the client and the target server (local network users, your ISP, the proxy, the target server's ISP, etc).\nThis less seriously affects HTTPS via HTTPS proxies. When you send HTTPS via a proxy to a remote server, the proxy can freely view or modify all HTTPS traffic unexpectedly (but only the proxy). \n\n### Patches\n\nThis issue was patched in Undici v5.5.1.\n\n### Workarounds\n\nAt the time of writing, the only workaround is to not use `ProxyAgent` as a dispatcher for TLS Connections.\nUpgrade to version 5.5.1 or later\n            ", "related_urls": []}
{"id": "CVE-2022-35949", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<=5.8.1", "fix_version": "5.8.2", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# `undici.request` vulnerable to SSRF using absolute URL on `pathname`\n### Impact\n\n`undici` is vulnerable to SSRF (Server side Request Forgery) when an application takes in **user input** into the `path/pathname` option of `undici.request`.\n\nIf a user specifies a URL such as `http://127.0.0.1` or `//127.0.0.1`\n\n```js\nconst undici = require(\"undici\")\nundici.request({origin: \"http://example.com\", pathname: \"//127.0.0.1\"})\n```\n\nInstead of processing the request as `http://example.org//127.0.0.1` (or `http://example.org/http://127.0.0.1` when `http://127.0.0.1 is used`), it actually processes the request as `http://127.0.0.1/` and sends it to `http://127.0.0.1`.\n\nIf a developer passes in user input into `path` parameter of `undici.request`, it can result in an _SSRF_ as they will assume that the hostname cannot change, when in actual fact it can change because the specified path parameter is combined with the base URL.\n\n### Patches\n\nThis issue was fixed in `undici@5.8.1`.\n\n### Workarounds\n\nThe best workaround is to validate user input before passing it to the `undici.request` call.\n\n## For more information\nIf you have any questions or comments about this advisory:\n\n  Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n  To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\n\nUpgrade to version 5.8.2 or later\n            ", "related_urls": []}
{"id": "CVE-2022-35948", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<=5.8.1", "fix_version": "5.8.2", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# Nodejs \u2018undici\u2019 Vulnerable to CRLF Injection via Content Type\n### Impact\n\n`=< undici@5.8.0` users are vulnerable to _CRLF Injection_ on headers when using unsanitized input as request headers, more specifically, inside the `content type` header.\n\nExample:\n\n```\nimport { request } from 'undici'\n\nconst unsanitizedContentTypeInput =  'application/json r n r nGET /foo2 HTTP/1.1'\n\nawait request('http://localhost:3000, {\n    method: 'GET',\n    headers: {\n      'content type': unsanitizedContentTypeInput\n    },\n})\n```\n\nThe above snippet will perform two requests in a single `request` API call:\n\n1) `http://localhost:3000/`\n2) `http://localhost:3000/foo2`\n\n### Patches\n\nThis issue was patched in Undici v5.8.1\n\n### Workarounds\n\nSanitize input when sending content type headers using user input.\n\n## For more information\nIf you have any questions or comments about this advisory:\n\n  Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n  To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\nUpgrade to version 5.8.2 or later\n            ", "related_urls": []}
{"id": "CVE-2022-31151", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<5.8.0", "fix_version": "5.8.0", "severity": "LOW", "cvss_score": "2.0", "short_description": "# undici before v5.8.0 vulnerable to uncleared cookies on cross host / cross origin redirect\n### Impact\n\nAuthorization headers are already cleared on cross origin redirect in\nhttps://github.com/nodejs/undici/blob/main/lib/handler/redirect.js#L189, based on https://github.com/nodejs/undici/issues/872.\n\nHowever, cookie headers which are sensitive headers and are official headers found in the spec, remain uncleared. There also has been active discussion of implementing a cookie store https://github.com/nodejs/undici/pull/1441, which suggests that there are active users using cookie headers in undici.\nAs such this may lead to accidental leakage of cookie to a 3rd party site or a malicious attacker who can control the redirection target (ie. an open redirector) to leak the cookie to the 3rd party site.\n\n### Patches\n\nThis was patched in v5.8.0.\n\n### Workarounds\n\nBy default, this vulnerability is not exploitable.\nDo not enable redirections, i.e. `maxRedirections: 0` (the default). \n\n### References\n\nhttps://hackerone.com/reports/1635514\nhttps://curl.se/docs/CVE 2018 1000007.html\nhttps://curl.se/docs/CVE 2022 27776.html\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n* To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\n\nUpgrade to version 5.8.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-31150", "package": "npm:undici", "package_type": "npm", "package_usage": "optional", "version": "<5.8.0", "fix_version": "5.8.0", "severity": "MEDIUM", "cvss_score": "5.0", "short_description": "# undici before v5.8.0 vulnerable to CRLF injection in request headers\n### Impact\n\nIt is possible to inject CRLF sequences into request headers in Undici.\n\n```js\nconst undici = require('undici')\n\nconst response = undici.request(\"http://127.0.0.1:1000\", {\n  headers: {'a': \" r nb\"}\n})\n```\n\nThe same applies to `path` and `method`\n\n### Patches\n\nUpdate to v5.8.0\n\n### Workarounds\n\nSanitize all HTTP headers from untrusted sources to eliminate ` r n`.\n\n### References\n\nhttps://hackerone.com/reports/409943\nhttps://cve.mitre.org/cgi bin/cvename.cgi?name=CVE 2018 12116\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n\n* Open an issue in [undici repository (https://github.com/nodejs/undici/issues)\n* To make a report, follow the [SECURITY (https://github.com/nodejs/node/blob/HEAD/SECURITY.md) document\n\nUpgrade to version 5.8.0 or later\n            ", "related_urls": []}
{"id": "CVE-2022-23712", "package": "elastic:elasticsearch", "package_type": "elastic", "package_usage": "optional", "version": ">=8.0.0-<8.2.1", "fix_version": "8.2.1", "severity": "HIGH", "cvss_score": "7.5", "short_description": "A Denial of Service flaw was discovered in Elasticsearch. Using this vulnerability, an unauthenticated attacker could forcibly shut down an Elasticsearch node with a specifically formatted network request.", "related_urls": ["https://www.elastic.co/community/security/", "https://discuss.elastic.co/t/elastic-stack-7-17-4-and-8-2-1-security-update/305530", "https://security.netapp.com/advisory/ntap-20220707-0010/"]}
{"id": "CVE-2022-33154", "package": "istanbuljs:schema", "package_type": "schema_project", "package_usage": "optional", "version": "<1.13.1", "fix_version": "1.13.1", "severity": "MEDIUM", "cvss_score": "5.4", "short_description": "The schema (aka Embedding schema.org vocabulary) extension before 1.13.1 and 2.x before 2.5.1 for TYPO3 allows XSS.", "related_urls": ["https://typo3.org/security/advisory/typo3-ext-sa-2022-012"]}
