{"tool": {"driver": {"name": "Shell Script Analysis", "rules": [{"id": "2068", "help": {"text": "Double quote array expansions to avoid re-splitting elements.", "markdown": "Double quote array expansions to avoid re-splitting elements."}, "name": "", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "note"}, "fullDescription": {"text": "Double quote array expansions to avoid re-splitting elements."}, "helpUri": "https://github.com/koalaman/shellcheck/wiki/SC2068", "shortDescription": {"text": "Double quote array expansions to avoid re-splitting elements."}}], "version": "1.0.0-scan", "fullName": "Shell Script Analysis"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["-a", "--shell=bash", "-f", "json", "-S", "error", "--color=never", "/github/workspace/check-news.sh", "/github/workspace/tools/massif.sh"], "executionSuccessful": true, "commandLine": "-a --shell=bash -f json -S error --color=never /github/workspace/check-news.sh /github/workspace/tools/massif.sh", "endTimeUtc": "2023-02-22T08:32:45Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-22T08:32:45Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}], "properties": {"metrics": {"total": 1, "critical": 0, "high": 0, "medium": 0, "low": 1}}, "results": [{"message": {"markdown": "", "text": "Double quote array expansions to avoid re-splitting elements."}, "level": "note", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "for i in $@ ; do\n"}, "startLine": 78}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/check-news.sh"}, "contextRegion": {"snippet": {"text": "\nfor i in $@ ; do\n"}, "endLine": 78, "startLine": 77}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "LOW", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "8e129c3194d18599", "scanFileHash": "840efee9c383a014"}, "ruleId": "2068", "ruleIndex": 0}], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "0c1aca2c-c8e7-4ba4-a702-3d3afb76f278"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
{"tool": {"driver": {"name": "Secrets Audit", "rules": [{"id": "CWE-312", "help": {"text": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\nBecause the information is stored in cleartext, attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.", "markdown": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\nBecause the information is stored in cleartext, attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information."}, "name": "Env Var", "properties": {"tags": ["Scan"], "precision": "very-high"}, "defaultConfiguration": {"level": "error"}, "fullDescription": {"text": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere."}, "helpUri": "https://cwe.mitre.org/data/definitions/312.html", "shortDescription": {"text": "Cleartext Storage of Sensitive Information."}}], "version": "1.0.0-scan", "fullName": "Secrets Audit"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["--config-path=/usr/local/src/lib/../credscan-config.toml", "--path=/github/workspace", "--leaks-exit-code=0", "--no-git", "--report=/github/workspace/reports/credscan-report.json"], "executionSuccessful": true, "commandLine": "--config-path=/usr/local/src/lib/../credscan-config.toml --path=/github/workspace --leaks-exit-code=0 --no-git --report=/github/workspace/reports/credscan-report.json", "endTimeUtc": "2023-02-22T08:33:37Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-22T08:33:37Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}], "properties": {"metrics": {"total": 9, "critical": 0, "high": 9, "medium": 0, "low": 0}}, "results": [{"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine: \t\t\tpassword = builder.get_object(\"password_entry\").get_text()\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "\t\t\tpassword = builder.get_object(\"password_entry\").get_text()"}, "startLine": 194}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/plugins/magnatune/magnatune.py"}, "contextRegion": {"snippet": {"text": "\t\t\tpassword = builder.get_object(\"password_entry\").get_text()"}, "endLine": 194, "startLine": 194}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "af52ac6c1d8c7742", "scanFileHash": "21a856124fd2ba2b"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\","}, "startLine": 716}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\","}, "endLine": 716, "startLine": 716}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "9a9382839a3e1373", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\""}, "startLine": 717}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\""}, "endLine": 717, "startLine": 717}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "a541855ffb7a5ce5", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\","}, "startLine": 743}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\","}, "endLine": 743, "startLine": 743}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "e77b24ab4c24cf2f", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\""}, "startLine": 744}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\""}, "endLine": 744, "startLine": 744}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "8ce0e3e0f924c6a2", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\","}, "startLine": 1607}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\","}, "endLine": 1607, "startLine": 1607}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "ace693e453ef5296", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\""}, "startLine": 1608}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\""}, "endLine": 1608, "startLine": 1608}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "c9558570234d0134", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\",\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\","}, "startLine": 1769}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\","}, "endLine": 1769, "startLine": 1769}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "d29ab106b256255d", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\"\n\nCommit: ."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "            \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\""}, "startLine": 1770}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif"}, "contextRegion": {"snippet": {"text": "            \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\""}, "endLine": 1770, "startLine": 1770}}}], "properties": {"issue_confidence": "MEDIUM", "issue_severity": "HIGH", "issue_tags": {}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "1d1c2da8d5dd1d46", "scanFileHash": "3e42ee1c6727d6de"}, "ruleId": "CWE-312", "ruleIndex": 0}], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "a5d8c8ed-6c16-4cff-9b37-31e21c7437a0"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
{"tool": {"driver": {"name": "Python Security Analysis", "rules": [{"id": "taint-rce", "help": {"text": "The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\nThis could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage. There are at least two subtypes of OS command injection: The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(nslookup [HOSTNAME]) to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing. The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use exec([COMMAND]) to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line. From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.", "markdown": "The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\nThis could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage. There are at least two subtypes of OS command injection: The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(nslookup [HOSTNAME]) to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing. The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use exec([COMMAND]) to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line. From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input."}, "name": "Remote Code Execution", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "error"}, "fullDescription": {"text": "The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component."}, "helpUri": "https://cwe.mitre.org/data/definitions/78.html", "shortDescription": {"text": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')."}}, {"id": "taint-traversal", "help": {"text": "The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.\nMany file operations are intended to take place within a restricted directory. By using special elements such as .. and / separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ../ sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as /usr/local/bin, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal. In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the software may add .txt to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.", "markdown": "The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.\nMany file operations are intended to take place within a restricted directory. By using special elements such as .. and / separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ../ sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as /usr/local/bin, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal. In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the software may add .txt to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction."}, "name": "Directory Traversal", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "error"}, "fullDescription": {"text": "The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory."}, "helpUri": "https://cwe.mitre.org/data/definitions/22.html", "shortDescription": {"text": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')."}}, {"id": "taint-file-write", "help": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.", "markdown": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data."}, "name": "File Write", "properties": {"tags": ["Scan"], "precision": "high"}, "defaultConfiguration": {"level": "error"}, "fullDescription": {"text": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors."}, "helpUri": "https://cwe.mitre.org/data/definitions/732.html", "shortDescription": {"text": "Incorrect Permission Assignment for Critical Resource."}}], "version": "1.0.0-scan", "fullName": "Python Security Analysis"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["-j", "-a", "e", "-o", "/github/workspace/reports/taint-python-report.json"], "executionSuccessful": true, "commandLine": "-j -a e -o /github/workspace/reports/taint-python-report.json", "endTimeUtc": "2023-02-22T08:32:43Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-22T08:32:43Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}], "properties": {"metrics": {"total": 5, "critical": 5, "high": 0, "medium": 0, "low": 0}}, "results": [{"message": {"markdown": "", "text": "Remote Code Execution via shell with user data from `s in siphash.py:239` used for constructing the command at `siphash.py:241`."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "    def relaxed_eval(s):\n"}, "startLine": 239}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/plugins/webremote/siphash.py"}, "contextRegion": {"snippet": {"text": "\n    def relaxed_eval(s):\n        if s.strip():\n            return eval(s)\n"}, "endLine": 241, "startLine": 238}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "CRITICAL", "issue_tags": {"source_trigger_word": "Framework function URL parameter", "source_label": "s", "source_type": "Framework_Parameter", "sink_trigger_word": "eval(", "sink_label": "~call_1 = ret_eval(s)", "sink_type": "RemoteCodeExecution"}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "346c8534d87f0617", "scanTagsHash": "ef18d5f74250ed2f", "scanFileHash": "95c5aa7092275cb3"}, "ruleId": "taint-rce", "ruleIndex": 0}, {"message": {"markdown": "", "text": "Exfiltration of data (Path Traversal) due to user data from `filename in webremote.py:387` influencing file operations in `webremote.py:389`."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "\tdef send_file_response(self, msg, filename, content_type):\n"}, "startLine": 387}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/plugins/webremote/webremote.py"}, "contextRegion": {"snippet": {"text": "\n\tdef send_file_response(self, msg, filename, content_type):\n\t\ttry:\n\t\t\tfp = open(filename, 'rb')\n"}, "endLine": 389, "startLine": 386}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "CRITICAL", "issue_tags": {"source_trigger_word": "Framework function URL parameter", "source_label": "filename", "source_type": "Framework_Parameter", "sink_trigger_word": "open(", "sink_label": "~call_1 = ret_open(filename, rb)", "sink_type": "Exfiltration"}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "42813b0faaa85489", "scanTagsHash": "ca48ec4ec59195c0", "scanFileHash": "c8350cd318a060b8"}, "ruleId": "taint-traversal", "ruleIndex": 1}, {"message": {"markdown": "", "text": "User data from `data in URLCache.py:144` is used in `URLCache.py:156` for file operations."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "    def store(self, key, data):\n"}, "startLine": 144}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/plugins/rb/URLCache.py"}, "contextRegion": {"snippet": {"text": "\n    def store(self, key, data):\n        \"\"\"\n        Stores an entry in the cache.\n"}, "endLine": 146, "startLine": 143}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "CRITICAL", "issue_tags": {"source_trigger_word": "Framework function URL parameter", "source_label": "data", "source_type": "Framework_Parameter", "sink_trigger_word": "f.write(", "sink_label": "~call_4 = ret_f.write(data)", "sink_type": "FileSystem"}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "8b0e91938f2173e1", "scanTagsHash": "535f943b8896e2f2", "scanFileHash": "fab86c76437a8f8b"}, "ruleId": "taint-file-write", "ruleIndex": 2}, {"message": {"markdown": "", "text": "User data from `artist in lyrics.py:119` is used in `lyrics.py:131` for file operations."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "def build_cache_path(artist, title):\n"}, "startLine": 119}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/plugins/lyrics/lyrics.py"}, "contextRegion": {"snippet": {"text": "\t\ndef build_cache_path(artist, title):\n\tsettings = Gio.Settings.new(\"org.gnome.rhythmbox.plugins.lyrics\")\n\tfolder = settings['folder']\n"}, "endLine": 121, "startLine": 118}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "CRITICAL", "issue_tags": {"source_trigger_word": "Framework function URL parameter", "source_label": "artist", "source_type": "Framework_Parameter", "sink_trigger_word": "os.mkdir(", "sink_label": "~call_7 = ret_os.mkdir(artist_folder)", "sink_type": "FileSystem"}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "605855929a396e9d", "scanTagsHash": "7dcefa7a0014341a", "scanFileHash": "8efa7ce2a319f4ee"}, "ruleId": "taint-file-write", "ruleIndex": 2}, {"message": {"markdown": "", "text": "User data from `text in lyrics.py:230` is used in `lyrics.py:232` for file operations."}, "level": "error", "locations": [{"physicalLocation": {"region": {"snippet": {"text": "\tdef lyrics_found(self, text):\n"}, "startLine": 230}, "artifactLocation": {"uri": "https://github.com/gnome/rhythmbox/plugins/lyrics/lyrics.py"}, "contextRegion": {"snippet": {"text": "\n\tdef lyrics_found(self, text):\n\t\tf = open(self.cache_path, 'wt')\n\t\tf.write(text)\n"}, "endLine": 232, "startLine": 229}}}], "properties": {"issue_confidence": "HIGH", "issue_severity": "CRITICAL", "issue_tags": {"source_trigger_word": "Framework function URL parameter", "source_label": "text", "source_type": "Framework_Parameter", "sink_trigger_word": "f.write(", "sink_label": "~call_2 = ret_f.write(text)", "sink_type": "FileSystem"}}, "baselineState": "new", "partialFingerprints": {"scanPrimaryLocationHash": "edc36b95e6018c59", "scanTagsHash": "517439922300a9a4", "scanFileHash": "8efa7ce2a319f4ee"}, "ruleId": "taint-file-write", "ruleIndex": 2}], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "dc62550c-ef2c-4bf8-8993-685bf2d77883"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
{"tool": {"driver": {"name": "Python Source Analyzer", "version": "1.0.0-scan", "fullName": "Python Source Analyzer"}}, "conversion": {"tool": {"driver": {"name": "@ShiftLeft/sast-scan"}}, "invocation": {"arguments": ["-r", "-a", "vuln", "-n", "3", "-s", "B101,B102,B105,B307,B308,B310,B322,B404,B601,B602,B603,B604,B605,B701,B702,B703", "-iii", "-ll", "-o", "/github/workspace/reports/source-python-report.json", "-f", "json", "-x", ".git,.svn,.mvn,.idea,.github,.hg,dist,obj,backup,docs,tests,test,test-packages,tmp,report,reports,node_modules,.terraform,.serverless,venv,.virtualenv,vendor,bower_components,.vscode,e2e,.pytest_cache,__pycache__,.storybook,.venv,.tox,examples,tutorials,samples,migrations,db_migrations,unittests,unittests_legacy,stubs,cypress,mock,mocks", "/github/workspace"], "executionSuccessful": true, "commandLine": "-r -a vuln -n 3 -s B101,B102,B105,B307,B308,B310,B322,B404,B601,B602,B603,B604,B605,B701,B702,B703 -iii -ll -o /github/workspace/reports/source-python-report.json -f json -x .git,.svn,.mvn,.idea,.github,.hg,dist,obj,backup,docs,tests,test,test-packages,tmp,report,reports,node_modules,.terraform,.serverless,venv,.virtualenv,vendor,bower_components,.vscode,e2e,.pytest_cache,__pycache__,.storybook,.venv,.tox,examples,tutorials,samples,migrations,db_migrations,unittests,unittests_legacy,stubs,cypress,mock,mocks /github/workspace", "endTimeUtc": "2023-02-22T08:32:43Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}}, "invocations": [{"executionSuccessful": true, "endTimeUtc": "2023-02-22T08:32:43Z", "workingDirectory": {"uri": "https://github.com/gnome/rhythmbox"}}], "properties": {"metrics": {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0}}, "results": [], "automationDetails": {"description": {"text": "Static Analysis Security Test results using @ShiftLeft/sast-scan"}, "guid": "74f597b6-c1ef-4629-a255-83f0caef9355"}, "versionControlProvenance": [{"branch": "main", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f"}]}
