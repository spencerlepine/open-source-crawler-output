{"findings": [{"app": "open-source-crawler", "type": "extscan", "title": "Double quote array expansions to avoid re-splitting elements.", "description": "Double quote array expansions to avoid re-splitting elements.\n\n## Additional information\n\n**[2068](https://github.com/koalaman/shellcheck/wiki/SC2068)**", "internal_id": "2068/71acb681eea7a0427c7cceb614b58e67", "severity": "info", "owasp_category": "", "category": "2068", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Double quote array expansions to avoid re-splitting elements.", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/check-news.sh", "DATA_TYPE": "OSS_SCAN", "lineNumber": 78, "ruleId": "2068", "ruleName": "", "contextText": "for i in $@ ; do\n", "snippetText": "\nfor i in $@ ; do\n"}, "tags": []}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine: \t\t\tpassword = builder.get_object(\"password_entry\").get_text()\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/fb61b04e9f90257e42fbf32377354919", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine: \t\t\tpassword = builder.get_object(\"password_entry\").get_text()\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/plugins/magnatune/magnatune.py", "DATA_TYPE": "OSS_SCAN", "lineNumber": 194, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "\t\t\tpassword = builder.get_object(\"password_entry\").get_text()", "snippetText": "\t\t\tpassword = builder.get_object(\"password_entry\").get_text()"}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\",\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/faff0b112142998cbcadb5041d4cebe8", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\",\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 716, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\",", "snippetText": "            \"text\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\","}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\"\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/b9c1f06faf9790b5891bafa9715b4612", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\"\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 717, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\"", "snippetText": "            \"markdown\" : \"# Clear-text logging of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\\n\""}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\",\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/3722a79c30ba206be45a7530d61053af", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\",\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 743, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\",", "snippetText": "            \"text\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\","}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\"\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/fa802e7dcedea86fcd9887aa882596c6", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\"\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 744, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\"", "snippetText": "            \"markdown\" : \"# Clear text storage of sensitive information\\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\\n\\n\\n## Recommendation\\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\\n\\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\\n\\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\\n\\n\\n## Example\\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\\n\\n\\n```javascript\\nvar express = require('express');\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // BAD: Setting a cookie value with cleartext sensitive data.\\n  res.cookie(\\\"password\\\", pw);\\n});\\n\\n```\\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\\n\\n\\n```javascript\\nvar express = require('express');\\nvar crypto = require('crypto'),\\n    password = getPassword();\\n\\nfunction encrypt(text){\\n  var cipher = crypto.createCipher('aes-256-ctr', password);\\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\\n}\\n\\nvar app = express();\\napp.get('/remember-password', function (req, res) {\\n  let pw = req.param(\\\"current_password\\\");\\n  // GOOD: Encoding the value before setting it.\\n  res.cookie(\\\"password\\\", encrypt(pw));\\n});\\n\\n```\\n\\n## References\\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\\n\""}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\",\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/d58fbe00aa62adc5ef062eb3392bc968", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\",\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 1607, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\",", "snippetText": "            \"text\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\","}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\"\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/33d070b8ccfdf58e92a9ada4b547e86f", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\"\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 1608, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\"", "snippetText": "            \"markdown\" : \"# Host header poisoning in email generation\\nUsing the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.\\n\\nIf the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\\n\\n\\n## Recommendation\\nObtain the server's host name from a configuration file and avoid relying on the Host header.\\n\\n\\n## Example\\nThe following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${req.host}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\nTo ensure the link refers to the correct web site, get the host name from a configuration file:\\n\\n\\n```javascript\\nlet nodemailer = require('nodemailer');\\nlet express = require('express');\\nlet backend = require('./backend');\\n\\nlet app = express();\\n\\nlet config = JSON.parse(fs.readFileSync('config.json', 'utf8'));\\n\\napp.post('/resetpass', (req, res) => {\\n  let email = req.query.email;\\n  let transport = nodemailer.createTransport(config.smtp);\\n  let token = backend.getUserSecretResetToken(email);\\n  transport.sendMail({\\n    from: 'webmaster@example.com',\\n    to: email,\\n    subject: 'Forgot password',\\n    text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,\\n  });\\n});\\n\\n```\\n\\n## References\\n* Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).\\n* Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).\\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\\n\""}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\",\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/2305c14c791b4e3be96d08c8aa242c6e", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\",\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 1769, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\",", "snippetText": "            \"text\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\","}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\"\n\nCommit: .", "description": "The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.\n\n## Additional information\n\n**[Env Var](https://cwe.mitre.org/data/definitions/312.html)**", "internal_id": "CWE-312/64baa0c7a29d0bbedf19bf37f8670036", "severity": "moderate", "owasp_category": "", "category": "Env Var", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Credential in plaintext?\n\nRule: Env Var\nLine:             \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\"\n\nCommit: .", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/security/codeql/javascript.sarif", "DATA_TYPE": "OSS_SCAN", "lineNumber": 1770, "ruleId": "CWE-312", "ruleName": "Env Var", "contextText": "            \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\"", "snippetText": "            \"markdown\" : \"# Sensitive data read from GET request\\nSensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.\\n\\n\\n## Recommendation\\nUse HTTP POST to send sensitive information as part of the request body; for example, as form data.\\n\\n\\n## Example\\nThe following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.\\n\\n\\n```javascript\\nconst express = require('express');\\nconst app = express();\\napp.use(require('body-parser').urlencoded({ extended: false }))\\n\\n// bad: sensitive information is read from query parameters\\napp.get('/login1', (req, res) => {\\n    const user = req.query.user;\\n    const password = req.query.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n// good: sensitive information is read from post body\\napp.post('/login2', (req, res) => {\\n    const user = req.body.user;\\n    const password = req.body.password;\\n    if (checkUser(user, password)) {\\n        res.send('Welcome');\\n    } else {\\n        res.send('Access denied');\\n    }\\n});\\n\\n```\\n\\n## References\\n* CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)\\n* PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)\\n* OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)\\n* Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).\\n\""}, "tags": [{"key": "cwe_category", "value": "312", "shiftleft_managed": true}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Remote Code Execution via shell with user data from `s in siphash.py:239` used for constructing the command at `siphash.py:241`.", "description": "The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n## Additional information\n\n**[Remote Code Execution](https://cwe.mitre.org/data/definitions/78.html)**", "internal_id": "taint-rce/22fff8c14942f7b345dbe95dd59adcdd", "severity": "critical", "owasp_category": "a1-injection", "category": "Remote Code Execution", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Remote Code Execution via shell with user data from `s in siphash.py:239` used for constructing the command at `siphash.py:241`.", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/plugins/webremote/siphash.py", "DATA_TYPE": "OSS_SCAN", "lineNumber": 239, "ruleId": "taint-rce", "ruleName": "Remote Code Execution", "contextText": "    def relaxed_eval(s):\n", "snippetText": "\n    def relaxed_eval(s):\n        if s.strip():\n            return eval(s)\n"}, "tags": [{"key": "source_trigger_word", "value": "Framework function URL parameter", "shiftleft_managed": false}, {"key": "source_label", "value": "s", "shiftleft_managed": false}, {"key": "source_type", "value": "Framework_Parameter", "shiftleft_managed": false}, {"key": "sink_trigger_word", "value": "eval(", "shiftleft_managed": false}, {"key": "sink_label", "value": "~call_1 = ret_eval(s)", "shiftleft_managed": false}, {"key": "sink_type", "value": "RemoteCodeExecution", "shiftleft_managed": false}]}, {"app": "open-source-crawler", "type": "extscan", "title": "Exfiltration of data (Path Traversal) due to user data from `filename in webremote.py:387` influencing file operations in `webremote.py:389`.", "description": "The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.\n\n## Additional information\n\n**[Directory Traversal](https://cwe.mitre.org/data/definitions/22.html)**", "internal_id": "taint-traversal/532e07fb9a7a812256f86294396fae09", "severity": "critical", "owasp_category": "a5-broken-access-control", "category": "Directory Traversal", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "Exfiltration of data (Path Traversal) due to user data from `filename in webremote.py:387` influencing file operations in `webremote.py:389`.", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/plugins/webremote/webremote.py", "DATA_TYPE": "OSS_SCAN", "lineNumber": 387, "ruleId": "taint-traversal", "ruleName": "Directory Traversal", "contextText": "\tdef send_file_response(self, msg, filename, content_type):\n", "snippetText": "\n\tdef send_file_response(self, msg, filename, content_type):\n\t\ttry:\n\t\t\tfp = open(filename, 'rb')\n"}, "tags": [{"key": "source_trigger_word", "value": "Framework function URL parameter", "shiftleft_managed": false}, {"key": "source_label", "value": "filename", "shiftleft_managed": false}, {"key": "source_type", "value": "Framework_Parameter", "shiftleft_managed": false}, {"key": "sink_trigger_word", "value": "open(", "shiftleft_managed": false}, {"key": "sink_label", "value": "~call_1 = ret_open(filename, rb)", "shiftleft_managed": false}, {"key": "sink_type", "value": "Exfiltration", "shiftleft_managed": false}]}, {"app": "open-source-crawler", "type": "extscan", "title": "User data from `data in URLCache.py:144` is used in `URLCache.py:156` for file operations.", "description": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\n\n## Additional information\n\n**[File Write](https://cwe.mitre.org/data/definitions/732.html)**", "internal_id": "taint-file-write/316b46abb4b32266319f60108af3a1c6", "severity": "critical", "owasp_category": "a5-broken-access-control", "category": "File Write", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "User data from `data in URLCache.py:144` is used in `URLCache.py:156` for file operations.", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/plugins/rb/URLCache.py", "DATA_TYPE": "OSS_SCAN", "lineNumber": 144, "ruleId": "taint-file-write", "ruleName": "File Write", "contextText": "    def store(self, key, data):\n", "snippetText": "\n    def store(self, key, data):\n        \"\"\"\n        Stores an entry in the cache.\n"}, "tags": [{"key": "source_trigger_word", "value": "Framework function URL parameter", "shiftleft_managed": false}, {"key": "source_label", "value": "data", "shiftleft_managed": false}, {"key": "source_type", "value": "Framework_Parameter", "shiftleft_managed": false}, {"key": "sink_trigger_word", "value": "f.write(", "shiftleft_managed": false}, {"key": "sink_label", "value": "~call_4 = ret_f.write(data)", "shiftleft_managed": false}, {"key": "sink_type", "value": "FileSystem", "shiftleft_managed": false}]}, {"app": "open-source-crawler", "type": "extscan", "title": "User data from `artist in lyrics.py:119` is used in `lyrics.py:131` for file operations.", "description": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\n\n## Additional information\n\n**[File Write](https://cwe.mitre.org/data/definitions/732.html)**", "internal_id": "taint-file-write/cdd0fdfd52e7ba6c2576811360416e2b", "severity": "critical", "owasp_category": "a5-broken-access-control", "category": "File Write", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "User data from `artist in lyrics.py:119` is used in `lyrics.py:131` for file operations.", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/plugins/lyrics/lyrics.py", "DATA_TYPE": "OSS_SCAN", "lineNumber": 119, "ruleId": "taint-file-write", "ruleName": "File Write", "contextText": "def build_cache_path(artist, title):\n", "snippetText": "\t\ndef build_cache_path(artist, title):\n\tsettings = Gio.Settings.new(\"org.gnome.rhythmbox.plugins.lyrics\")\n\tfolder = settings['folder']\n"}, "tags": [{"key": "source_trigger_word", "value": "Framework function URL parameter", "shiftleft_managed": false}, {"key": "source_label", "value": "artist", "shiftleft_managed": false}, {"key": "source_type", "value": "Framework_Parameter", "shiftleft_managed": false}, {"key": "sink_trigger_word", "value": "os.mkdir(", "shiftleft_managed": false}, {"key": "sink_label", "value": "~call_7 = ret_os.mkdir(artist_folder)", "shiftleft_managed": false}, {"key": "sink_type", "value": "FileSystem", "shiftleft_managed": false}]}, {"app": "open-source-crawler", "type": "extscan", "title": "User data from `text in lyrics.py:230` is used in `lyrics.py:232` for file operations.", "description": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\n\n## Additional information\n\n**[File Write](https://cwe.mitre.org/data/definitions/732.html)**", "internal_id": "taint-file-write/c15593cf5ab063d52e04a365eed151b8", "severity": "critical", "owasp_category": "a5-broken-access-control", "category": "File Write", "details": {"repoContext": {"gitProvider": "github", "ciProvider": "github", "repositoryName": "open-source-crawler", "repositoryUri": "https://github.com/spencerlepine/open-source-crawler", "revisionId": "735748ce709a4271f6944b183a2c0a8c2573b40f", "branch": "main", "invokedBy": "Jonathan Matthew <jonathan@d14n.org>", "pullRequest": false, "botUser": false}, "name": "User data from `text in lyrics.py:230` is used in `lyrics.py:232` for file operations.", "tags": "Scan", "fileName": "https://github.com/gnome/rhythmbox/plugins/lyrics/lyrics.py", "DATA_TYPE": "OSS_SCAN", "lineNumber": 230, "ruleId": "taint-file-write", "ruleName": "File Write", "contextText": "\tdef lyrics_found(self, text):\n", "snippetText": "\n\tdef lyrics_found(self, text):\n\t\tf = open(self.cache_path, 'wt')\n\t\tf.write(text)\n"}, "tags": [{"key": "source_trigger_word", "value": "Framework function URL parameter", "shiftleft_managed": false}, {"key": "source_label", "value": "text", "shiftleft_managed": false}, {"key": "source_type", "value": "Framework_Parameter", "shiftleft_managed": false}, {"key": "sink_trigger_word", "value": "f.write(", "shiftleft_managed": false}, {"key": "sink_label", "value": "~call_2 = ret_f.write(text)", "shiftleft_managed": false}, {"key": "sink_type", "value": "FileSystem", "shiftleft_managed": false}]}]}